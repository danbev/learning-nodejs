### V8 Heap Snapshot builder
This feature in v8 that enables a snapshot of the heap to be taken (not to be
confused with the snapshot generated by mksnapshot or node_mksnapshot.

Upon startup of Node `LoadEnvironment` will call the following function:
```c++
void Environment::InitializeDiagnostics() {
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
```
```console
$ lldb -- ./out/Debug/node -p 'process.versions.v8'
(lldb) br s -n Environment::InitializeDiagnostics
(lldb) r
```
This is adding a callback that will be called during heap snapshot generation
is in progress, allowing an embedder to add nodes and edges to the EmbedderGraph
that is passed to this callback. The implementation can be found in env.cc:
```c++
void Environment::BuildEmbedderGraph(Isolate* isolate,
                                     EmbedderGraph* graph,
                                     void* data) {
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  tracker.Track(env);
  env->ForEachBaseObject([&](BaseObject* obj) {
    if (obj->IsDoneInitializing())
      tracker.Track(obj);
  });
}
```
First notice that an instance of `MemoryTracker` is being created. Next, the
environment pointer is casted from the `void* data` pointer.
After that we have the call to `tracker.Track(env)`: 
```c++
  inline void Track(const MemoryRetainer* retainer,
                    const char* edge_name = nullptr);
```
And note that Environment extends MemoryRetainer which why `Track` can be
called:
```c++
class Environment : public MemoryRetainer {
```
So what does `Track` do (src/memory_tracker-inl.h):
```c++
void MemoryTracker::Track(const MemoryRetainer* retainer,
                          const char* edge_name) {
  v8::HandleScope handle_scope(isolate_);
  auto it = seen_.find(retainer);
  if (it != seen_.end()) {
    if (CurrentNode() != nullptr) {
      graph_->AddEdge(CurrentNode(), it->second, edge_name);
    }
    return;  // It has already been tracked, no need to call MemoryInfo again
  }
  MemoryRetainerNode* n = PushNode(retainer, edge_name);
  retainer->MemoryInfo(this);
  CHECK_EQ(CurrentNode(), n);
  CHECK_NE(n->size_, 0);
  PopNode();
```

#### MemoryTracker
This class is declared in src/memory-tracker.h
```c++
class MemoryTracker {
 public:

  inline explicit MemoryTracker(v8::Isolate* isolate,
                                v8::EmbedderGraph* graph)
    : isolate_(isolate), graph_(graph) {}
 private:
  typedef std::unordered_map<const MemoryRetainer*, MemoryRetainerNode*> NodeMap;
  
  NodeMap seen_;
```
`seen_` is a map and the keys are the MemoryRetainer pointers, and values
are MemoryRetainerNode pointers.

#### MemoryRetainerNode 
This class is defined in src/memory_tracker-inl.h.
```c++
class MemoryRetainerNode : public v8::EmbedderGraph::Node {
 public:
  inline MemoryRetainerNode(MemoryTracker* tracker,
                            const MemoryRetainer* retainer) : retainer_(retainer) {
    v8::HandleScope handle_scope(tracker->isolate());
    v8::Local<v8::Object> obj = retainer_->WrappedObject();
    if (!obj.IsEmpty()) wrapper_node_ = tracker->graph()->V8Node(obj);

    name_ = retainer_->MemoryInfoName();
    size_ = retainer_->SelfSize();
  }
  
 private:
  const MemoryRetainer* retainer_;
  Node* wrapper_node_ = nullptr;

  // Otherwise (retainer == nullptr), we set these fields in an ad-hoc way
  bool is_root_node_ = false;
  std::string name_;
  size_t size_ = 0;
};
```

#### MemoryRetainer
