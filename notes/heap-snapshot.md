### V8 Heap Snapshot builder
This feature in v8 that enables a snapshot of the heap to be taken (not to be
confused with the snapshot generated by mksnapshot or node_mksnapshot.

Upon startup of Node `LoadEnvironment` will call the following function:
```c++
void Environment::InitializeDiagnostics() {
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
```
```console
$ lldb -- ./out/Debug/node -p 'process.versions.v8'
(lldb) br s -n Environment::InitializeDiagnostics
(lldb) r
```
This is adding a callback that will be called during heap snapshot generation
is in progress, allowing an embedder to add nodes and edges to the EmbedderGraph
that is passed to this callback. The implementation can be found in env.cc:
```c++
void Environment::BuildEmbedderGraph(Isolate* isolate,
                                     EmbedderGraph* graph,
                                     void* data) {
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  tracker.Track(env);
  env->ForEachBaseObject([&](BaseObject* obj) {
    if (obj->IsDoneInitializing())
      tracker.Track(obj);
  });
}
```
First notice that an instance of `MemoryTracker` is being created. Next, the
environment pointer is casted from the `void* data` pointer.
After that we have the call to `tracker.Track(env)`: 
```c++
  inline void Track(const MemoryRetainer* retainer,
                    const char* edge_name = nullptr);
```
And note that Environment extends MemoryRetainer which why `Track` can be
called:
```c++
class Environment : public MemoryRetainer {
```
So what does `Track` do (src/memory_tracker-inl.h):
```c++
void MemoryTracker::Track(const MemoryRetainer* retainer,
                          const char* edge_name) {
  v8::HandleScope handle_scope(isolate_);
  auto it = seen_.find(retainer);
  if (it != seen_.end()) {
    if (CurrentNode() != nullptr) {
      graph_->AddEdge(CurrentNode(), it->second, edge_name);
    }
    return;  // It has already been tracked, no need to call MemoryInfo again
  }
  MemoryRetainerNode* n = PushNode(retainer, edge_name);
  retainer->MemoryInfo(this);
  CHECK_EQ(CurrentNode(), n);
  CHECK_NE(n->size_, 0);
  PopNode();
```
If the MemoryRetainer passed in is in the `seen_` map then an edge/link from
the current node to it will be added to the graph. 
If the MemoryRetainer was not in the map a new MemoryRetainerNode will be
created by calling `PushNode`.
```c++
MemoryRetainerNode* MemoryTracker::PushNode(const MemoryRetainer* retainer,
                                            const char* edge_name) {
  MemoryRetainerNode* n = AddNode(retainer, edge_name);
  node_stack_.push(n);
  return n;
}
```
After the MemoryRetainerNode has been created and added, `retainer->MemoryInfo`
will be called allowing the current MemoryRetainer to add fields to the
MemoryTracker. For example, for Environment this will call
`Environment::MemoryInfo(MemoryTracker* tracker)`:
```c++
  tracker->TrackField("isolate_data", isolate_data_);
```
So we are passing `isolate_data` as the `edge_name`, and in our case this
retainers (isolate_data) has not been added to the map so `Track` will 
create a new MemoryRetainerNode by using PushNode like we saw earlier and
then call isolate_data->MemoryInfo(this) which has a few macros which can
be expanded using:
```console
$ g++ -DNODE_WANT_INTERNALS=true -E -Ideps/uv/include -Ideps/v8/include -Isrc src/env.cc
```
```c++
void IsolateData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField("async_id_symbol", async_id_symbol());
  ...
```
This will call `TrackField` in memory_tracker-inl.h:
```c++
template <typename T>
void MemoryTracker::TrackField(const char* edge_name,
                               const v8::Local<T>& value,
                               const char* node_name) {
  if (!value.IsEmpty())
    graph_->AddEdge(CurrentNode(), graph_->V8Node(value), edge_name);
}
```
TODO: continue this walkthrough.


When debugging you might not see correct values for std::string's. For example
you might see:
```console
(lldb) expr name_
(std::string) $0 = "error: summary string parsing error"

```
This can be fixed by specifying `-fno-limit-debug-info` in `node.gypi`:
```
    [ 'debug_node=="true"', {
      'cflags!': [ '-O3' ],
      'cflags': [ '-g', '-O0', '-fno-limit-debug-info' ],
```
Note that this makes debug build time longer.
```console
(lldb) expr name_
(std::string) $0 = "Environment"
```

#### MemoryTracker
This class is declared in src/memory-tracker.h
```c++
class MemoryTracker {
 public:

  inline explicit MemoryTracker(v8::Isolate* isolate,
                                v8::EmbedderGraph* graph)
    : isolate_(isolate), graph_(graph) {}
 private:
  typedef std::unordered_map<const MemoryRetainer*, MemoryRetainerNode*> NodeMap;
  
  NodeMap seen_;
```
`seen_` is a map and the keys are the MemoryRetainer pointers, and values
are MemoryRetainerNode pointers.

#### MemoryRetainerNode 
This class is defined in src/memory_tracker-inl.h.
```c++
class MemoryRetainerNode : public v8::EmbedderGraph::Node {
 public:
  inline MemoryRetainerNode(MemoryTracker* tracker,
                            const MemoryRetainer* retainer) : retainer_(retainer) {
    v8::HandleScope handle_scope(tracker->isolate());
    v8::Local<v8::Object> obj = retainer_->WrappedObject();
    if (!obj.IsEmpty()) wrapper_node_ = tracker->graph()->V8Node(obj);

    name_ = retainer_->MemoryInfoName();
    size_ = retainer_->SelfSize();
  }
  
 private:
  const MemoryRetainer* retainer_;
  Node* wrapper_node_ = nullptr;

  // Otherwise (retainer == nullptr), we set these fields in an ad-hoc way
  bool is_root_node_ = false;
  std::string name_;
  size_t size_ = 0;
};
```

#### MemoryRetainer
